"use strict";
var JBlockShape = require("./JBlockShape");
var LBlockShape = require("./LBlockShape");
var SBlockShape = require("./SBlockShape");
var ZBlockShape = require("./ZBlockShape");
var IBlockShape = require("./IBlockShape");
var SquareBlockShape = require("./SquareBlockShape");
var TBlockShape = require("./TBlockShape");
/**
 * To create this module I have read the following guide:
 * http://gamedevelopment.tutsplus.com/tutorials/implementing-tetris-collision-detection--gamedev-852
 */

function TetrisGame(element) {
    this.element = element;
    this.fallingBlock = undefined;
    this.field = [];
    this.alive = false;
    this.fullRows = [];
    this.basePoints = 100;
    this.points = 0;
    this.nextBlock = undefined;

    this.fallingBlockInterval = undefined;
}

TetrisGame.prototype.init = function() {
    this.initField();
    this.print();
};

TetrisGame.prototype.start = function() {
    this.alive = true;
    this.element.querySelector(".tetris-grid-body").classList.remove("game-over");
    this.initField();
    this.clearField();
    this.newNextBlock();
    this.dropNewBlock();
};

TetrisGame.prototype.fallBlock = function() {
    if (this.isFallable()) {
        this.fallingBlock.topLeft.row += 1;
    }
    else {
        window.clearInterval(this.fallingBlockInterval);
        this.landFallingBlock();
        this.dropNewBlock();
    }

    this.render();
};

TetrisGame.prototype.fallBlockToBottom = function() {
    while (this.isFallable()) {
        this.fallingBlock.topLeft.row += 1;
    }

    this.render();
};

TetrisGame.prototype.newNextBlock = function() {
    var shape = Math.floor(Math.random() * 7);

    switch (shape) {
        case 0: {
            this.nextBlock = new JBlockShape();
            break;
        }

        case 1: {
            this.nextBlock = new LBlockShape();
            break;
        }

        case 2: {
            this.nextBlock = new SBlockShape();
            break;
        }

        case 3: {
            this.nextBlock = new ZBlockShape();
            break;
        }

        case 4: {
            this.nextBlock = new IBlockShape();
            break;
        }

        case 5: {
            this.nextBlock = new SquareBlockShape();
            break;
        }

        case 6: {
            this.nextBlock = new TBlockShape();
            break;
        }
    }
};

TetrisGame.prototype.dropNewBlock = function() {
    this.fallingBlock = this.nextBlock;

    this.clearNextBlock();
    this.newNextBlock();

    this.fallingBlockInterval = window.setInterval(this.fallBlock.bind(this), 500);

    if (this.isCollision()) {
        console.log("Game over");
        this.element.querySelector(".tetris-grid-body").classList.add("game-over");
        this.alive = false;
        window.clearInterval(this.fallingBlockInterval);
    }
};

TetrisGame.prototype.landFallingBlock = function() {
    //this.clearFallingBlock();
    var shape = this.fallingBlock.shapes[this.fallingBlock.rotation];

    for (var row = 0; row < shape.length; row += 1) {
        for (var col = 0; col < shape[row].length; col += 1) {
            if (shape[row][col] !== 0) {
                this.field[row + this.fallingBlock.topLeft.row][col + this.fallingBlock.topLeft.col] = shape[row][col];
            }
        }
    }

    this.findFullRows();

    if (this.fullRows.length > 0) {
        this.eraseFullRows();
        this.points += this.countRowPoints();
        this.fullRows = [];
        console.log(this.points);
    }
};

TetrisGame.prototype.render = function() {
    //this.clearFallingBlock();
    this.clearField();

    // Change the classes to render the blocks to user
    var trs = this.element.querySelectorAll(".tetris-grid tr");
    var tds;
    for (var row = 0; row < this.field.length; row += 1) {
        tds = trs[row].querySelectorAll(".tetris-grid td");
        for (var col = 0; col < this.field[row].length; col += 1) {
            if (this.field[row][col] !== 0) {
                //should render class for block here
                tds[col].classList.add("tetris-block-part");
            }
        }
    }

    this.renderFallingBlock();
    this.renderNextBlock();
};

TetrisGame.prototype.renderFallingBlock = function() {
    var row;
    var col;

    //get the nodes
    var trs = this.element.querySelectorAll(".tetris-grid tr");
    var tds = [];
    for (row = 0; row < this.field.length; row += 1) {
        tds.push(trs[row].querySelectorAll(".tetris-grid td"));
    }

    var shape = this.fallingBlock.shapes[this.fallingBlock.rotation];
    for (row = 0; row < shape.length; row += 1) {
        for (col = 0; col < shape[row].length; col += 1) {
            if (shape[row][col] !== 0) {
                //draw block at position corresponding to the shapes position
                var y = row + this.fallingBlock.topLeft.row;
                var x = col + this.fallingBlock.topLeft.col;
                tds[y][x].classList.add("tetris-falling-block-part", "color-" + shape[row][col]);
            }
        }
    }
};

TetrisGame.prototype.renderNextBlock = function() {
    var row;
    var col;

    //get the nodes
    var trs = this.element.querySelectorAll(".tetris-next-block tbody tr");
    var tds = [];
    for (row = 0; row < trs.length; row += 1) {
        tds.push(trs[row].querySelectorAll("td"));
    }

    var shape = this.nextBlock.shapes[this.nextBlock.rotation];
    for (row = 0; row < shape.length; row += 1) {
        for (col = 0; col < shape[row].length; col += 1) {
            if (shape[row][col] !== 0) {
                //draw block at position corresponding to the shapes position
                //var y = row + this.fallingBlock.topLeft.row;
                //var x = col + this.fallingBlock.topLeft.col;
                tds[row][col].classList.add("tetris-falling-block-part", "color-" + shape[row][col]);
            }
        }
    }
};

TetrisGame.prototype.clearNextBlock = function() {
    //clear field
    console.log("clearing nextblock");
    var trs = this.element.querySelectorAll(".tetris-next-block tbody tr");
    var tds;
    for (var row = 0; row < trs.length; row += 1) {
        tds = trs[row].querySelectorAll("td");
        for (var col = 0; col < tds.length; col += 1) {
            tds[col].setAttribute("class", "");
        }
    }
};

TetrisGame.prototype.isCollision = function() {
    var collision = false;

    var shape = this.fallingBlock.shapes[this.fallingBlock.rotation];

    for (var row = 0; row < shape.length; row += 1) {
        for (var col = 0; col < shape[row].length; col += 1) {
            if (shape[row][col] !== 0) {
                if (row + this.fallingBlock.topLeft.row >= this.field.length) {
                    //this block would be below the playing field
                    collision = true;
                }

                //console.log(this.field[row + potentialTopLeft.row][col + potentialTopLeft.col]);
                else if (this.field[row + this.fallingBlock.topLeft.row][col + this.fallingBlock.topLeft.col] !== 0) {
                    //the space is taken
                    collision = true;
                }
            }
        }
    }

    return collision;
};

TetrisGame.prototype.isFallable = function() {
    var fallable = true;

    var shape = this.fallingBlock.shapes[this.fallingBlock.rotation];
    var potentialTopLeft = {
        row: this.fallingBlock.topLeft.row + 1,
        col: this.fallingBlock.topLeft.col
    };

    for (var row = 0; row < shape.length; row += 1) {
        for (var col = 0; col < shape[row].length; col += 1) {
            if (shape[row][col] !== 0) {
                if (row + potentialTopLeft.row >= this.field.length) {
                    //this block would be below the playing field
                    console.log("out of bounds");
                    fallable = false;
                }
                //console.log(this.field[row + potentialTopLeft.row][col + potentialTopLeft.col]);
                else if (this.field[row + potentialTopLeft.row][col + potentialTopLeft.col] !== 0) {
                    //the space is taken
                    console.log("collision");
                    fallable = false;
                }
            }
        }
    }

    return fallable;
};

TetrisGame.prototype.moveFallingBlock = function(dir) {
    if (this.isMovable(dir)) {
        this.fallingBlock.topLeft.col += dir;
    }

    this.render();
};

TetrisGame.prototype.isMovable = function(dir) {
    var movable = true;
    var shape = this.fallingBlock.shapes[this.fallingBlock.rotation];
    var potentialTopLeft = {
            row: this.fallingBlock.topLeft.row,
            col: this.fallingBlock.topLeft.col + dir
        };

    for (var row = 0; row < shape.length; row += 1) {
        for (var col = 0; col < shape[row].length; col += 1) {
            if (shape[row][col] !== 0) {
                if (col + potentialTopLeft.col < 0) {
                    //this block would be to the left of the playing field
                    movable = false;
                }
                if (col + potentialTopLeft.col >= this.field[0].length) {
                    //this block would be to the right of the playing field
                    movable = false;
                }
                if (this.field[row + potentialTopLeft.row][col + potentialTopLeft.col] !== 0) {
                    //the space is taken
                    movable = false;
                }
            }
        }
    }

    return movable;
};

TetrisGame.prototype.rotateFallingBlock = function(dir) {
    if (this.isRotatable(dir)) {
        var newRotation = this.fallingBlock.rotation + dir;
        if (newRotation > 3) {
            newRotation = 0;
        }
        else if (newRotation < 0) {
            newRotation = 3;
        }

        this.fallingBlock.rotation = newRotation;

        this.render();
    }

};

TetrisGame.prototype.isRotatable = function(dir) {
    var rotatable = true;

    var potentialRotation = this.fallingBlock.rotation + dir;
    if (potentialRotation > 3) {
        potentialRotation = 0;
    }
    else if (potentialRotation < 0) {
        potentialRotation = 3;
    }

    //create potential shape
    var potentialShape = this.fallingBlock.shapes[potentialRotation];


    for (var row = 0; row < potentialShape.length; row += 1) {
        for (var col = 0; col < potentialShape[row].length; col += 1) {
            if (potentialShape[row][col] !== 0) {
                if (col + this.fallingBlock.topLeft.col < 0) {
                    //this block would be to the left of the playing field
                    rotatable = false;
                }

                if (col + this.fallingBlock.topLeft.col >= this.field[0].length) {
                    //this block would be to the right of the playing field
                    rotatable = false;
                }

                if (this.field[row + this.fallingBlock.topLeft.row][col + this.fallingBlock.topLeft.col] !== 0) {
                    //the space is taken
                    rotatable = false;
                }
            }
        }
    }

    return rotatable;
};

TetrisGame.prototype.clearField = function() {
    //clear field
    var trs = this.element.querySelectorAll("tr");
    var tds;
    for (var row = 0; row < this.field.length; row += 1) {
        tds = trs[row].querySelectorAll("td");
        for (var col = 0; col < this.field[row].length; col += 1) {
            tds[col].setAttribute("class", "");
        }
    }
};

TetrisGame.prototype.findFullRows = function() {
    //find full rows
    var full = false;
    for (var row = 0; row < this.field.length; row += 1) {
        for (var col = 0; col < this.field[row].length - 1; col += 1) {
            if(this.field[row].indexOf(0) === -1) {
                //row is full
                full = true;
            }
        }
        if (full) {
            this.fullRows.push(row);
            full = false;
        }
    }
};

TetrisGame.prototype.eraseFullRows = function() {
    for (var i = 0; i < this.fullRows.length; i += 1) {
        //remove the full row from field
        this.field.splice(this.fullRows[i], 1);

        //add a new empty on top of field
        var newRow = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this.field.unshift(newRow);
    }
};

TetrisGame.prototype.countRowPoints = function() {
    return this.basePoints + ((this.fullRows.length - 1) * this.basePoints) * 1.2;
};

TetrisGame.prototype.print = function() {
    console.log("print field");
    //print the chat-template to this.element
    var template = document.querySelector("#template-tetris-application").content.cloneNode(true);

    var frag = document.createDocumentFragment();
    var tr;
    var td;

    for (var row = 0; row < this.field.length; row += 1) {
        tr = document.createElement("tr");
        //tr.setAttribute("id", "row-" + row);
        for (var col = 0; col < this.field[row].length; col += 1) {
            td = document.createElement("td");
            //td.setAttribute("id", "col-" + col);
            tr.appendChild(td);
        }
        frag.appendChild(tr);
    }

    template.querySelector(".tetris-grid-body").appendChild(frag);

    this.element.querySelector(".window-content").appendChild(template);
};

TetrisGame.prototype.initField = function() {
    this.field = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];
};

module.exports = TetrisGame;